## Project Architecture

This section provides an in-depth look at the architecture of the Trading Bot project, detailing the technologies, file structure, Docker packaging, and how services are deployed and accessed. The system is designed to simulate trading activity on a cryptocurrency exchange, with a modular structure supporting both Development and Demo environments.

### Technologies Used

The project leverages a modern tech stack for robustness and scalability:

*   **PHP 8.1:** Powers the backend logic, including the Trading Bot core (`src/core/TradingBot.php`), API (`api/api.php`), and configuration management (`config/config.php`).
*   **Apache:** Serves the PHP-based API within the backend Docker container, using URL rewriting via `.htaccess`.
*   **Nginx:** Acts as a reverse proxy and static file server for the frontend within its Docker container, configured via `nginx-dev.conf` and `nginx-demo.conf`.
*   **Docker:** Containers encapsulate the application, ensuring consistency across environments. Managed with `docker-compose-dev.yml` and `docker-compose-demo.yml`.
*   **Composer:** Manages PHP dependencies (e.g., `guzzlehttp/guzzle` for HTTP requests, `symfony/console` for CLI tools, `react/event-loop` suggesting asynchronous capabilities).
*   **TypeScript/Node.js:** Optional, potentially used in `utils/` or `tools/` for alternative monitoring tools (e.g., `OrderBookConsoleTool.ts`).
*   **JSON:** Configuration files (e.g., `config/bots_config.json`) store bot settings.
*   **Bash:** Shell scripts in the `scripts/` folder automate setup, deployment, and cleanup tasks.

### Docker Packaging

The project is packaged into Docker containers for both Development and Demo environments, each with distinct configurations:

*   **Base Images:**
    *   **PHP-FPM:** `api/Dockerfile` uses `php:8.1-fpm` with necessary extensions (pdo, mbstring, etc.) and Composer-installed dependencies. Apache runs alongside PHP-FPM.
    *   **Nginx:** `frontend/Dockerfile` uses `nginx:alpine` for lightweight frontend serving.
*   **Compose Files:**
    *   `docker-compose-dev.yml`: Defines services for Development:
        *   `app-dev`: PHP-FPM/Apache backend, mapped to host port **5501**.
        *   `nginx-dev`: Nginx frontend, mapped to host port **6501**.
    *   `docker-compose-demo.yml`: Defines services for Demo:
        *   `app-demo`: PHP-FPM/Apache backend, mapped to host port **5502**.
        *   `nginx-demo`: Nginx frontend, mapped to host port **6502**.
*   **Volumes:**
    *   Mounts local source directories (`api/`, `frontend/`, `public/`) into containers for live code updates during development.
    *   Mounts the `data/` directory to persist logs, PIDs, and locks outside the containers.
*   **Networking:** Each environment (Dev, Demo) runs on an isolated Docker network. Ports are mapped from the container to the host machine.

### File Structure and Purpose

Here's a breakdown of key files and directories:

*   **`api/`**: Contains the backend PHP application.
    *   **`.htaccess`**: Configures Apache URL rewriting, directing most requests to `api.php`. Includes rules for `/api/*` endpoints and potentially for serving Swagger documentation if handled by Apache/PHP.
    *   **`api.php`**: The central API entry point script. Handles incoming HTTP requests, routes them, interacts with core logic (like `src/core/TradingBot.php`), and returns responses.
*   **`config/`**: Holds configuration files.
    *   **`bots_config.json`**: Stores bot configurations (parameters like `trade_amount_min`, `price_factor`) for each trading pair. This is the primary source of bot settings at startup.
    *   **`config.php`**: Contains the main application configuration class (`Config`), potentially including database connections, paths, external service keys, and methods to load/manage settings from `bots_config.json`.
*   **`data/`**: Stores persistent and runtime data.
    *   **`locks/`**: Stores lock files, likely used to prevent duplicate instances of bots or processes.
    *   **`logs/`**: Contains log files generated by the application for debugging and monitoring, separated by environment (`dev/`, `demo/`, `local/`).
    *   **`pids/`**: Holds process ID files for background bot processes started locally, used by stop scripts.
*   **`frontend/`**: Contains the Nginx configuration for serving the frontend.
    *   **`Dockerfile`**: Builds the Nginx container, copying static files (from `public/`) and environment-specific Nginx configs.
    *   **`nginx-dev.conf`**: Nginx configuration for the Development environment. Serves static files and proxies requests starting with `/api` to the backend container (`http://app-dev:80`).
    *   **`nginx-demo.conf`**: Similar Nginx configuration for the Demo environment, proxying to the demo backend (`http://app-demo:80`).
*   **`public/`**: Contains static assets served by Nginx.
    *   **`docs/swagger.json`**: The OpenAPI (Swagger) specification file defining the structure and endpoints of the Trading Bot API.
    *   May contain other static frontend assets (HTML, CSS, JS) or redirect logic (`index.php`).
*   **`scripts/`**: Contains automation scripts.
    *   **`rebuild-all.sh`**: The main script to stop, rebuild, and start both Development and Demo Docker environments.
    *   **`clean_and_run_local.sh`**: Cleans up old logs/PIDs and launches bot processes directly on the host machine for debugging.
    *   **`stop-docker.sh`**: Stops and removes the Docker containers defined in the compose files.
    *   **`stop_all.sh`**: Stops both local bot processes (using `stop_bots.php`) and Docker containers (using `stop-docker.sh`).
    *   **`stop_bots.php`**: PHP script specifically for stopping locally running bot processes based on their PIDs in `data/pids/`.
    *   **`prepare-configs.sh`**: Helper script to prepare/copy configurations before starting services.
*   **`src/`**: Contains the core PHP source code.
    *   **`core/TradingBot.php`**: Likely the main class containing the core market-making logic, order book management (`initializeOrderBook`), order placement (`placeLimitOrder`, `placeMarketOrder`), and order maintenance (`maintainOrders`).
    *   **`helpers/LogManager.php`, `helpers/LogRotator.php`**: Utility classes responsible for handling application logging and log file rotation.
*   **`tools/` / `utils/`**: May contain utility scripts or tools.
    *   **`OrderBookConsoleTool.php` / `OrderBookConsoleTool.ts`**: CLI tools mentioned for monitoring order books in real-time (location might be `tools/`).

### Swagger Integration

The project utilizes Swagger (OpenAPI) for API documentation and interaction:

*   **Specification File:** `public/docs/swagger.json`.
*   **Purpose:** Defines all available API endpoints, their parameters, and expected responses (e.g., `GET /api/orderbook`, `POST /api/bot/start`, `POST /api/bot/update`).
*   **Access:** The Swagger UI provides a web interface to view the documentation and interact with the API. It's typically accessed via the backend service URL:
    *   Development: `http://localhost:5501/swagger-ui` (when running Docker locally) or `http://164.68.117.90:5501/swagger-ui` (deployed).
    *   Demo: `http://localhost:5502/swagger-ui` (when running Docker locally - *Note: Port mapping might differ for Demo backend*) or `http://164.68.117.90:5502/swagger-ui` (deployed). *Correction: Based on the Startup Guide, Demo API/Swagger runs on 5502.* -> Let's align with the Startup Guide consistently: Demo Swagger/API on port 5502.
    *   **Corrected Access:**
        *   Development (Local Docker): `http://localhost:5501`
        *   Demo (Local Docker): `http://localhost:5502`
        *   Development (Deployed): `http://164.68.117.90:5501`
        *   Demo (Deployed): `http://164.68.117.90:5502`

### Mounting and Deployment Details

*   **Docker Mounting:**
    *   Backend (`app-dev`/`app-demo`): `api/` directory mounted to `/var/www/html`. `vendor/` dependencies are within the container.
    *   Frontend (`nginx-dev`/`nginx-demo`): `public/` directory mounted to `/usr/share/nginx/html`. Nginx configs copied into the container.
    *   Shared Data: `data/` directory mounted for logs, PIDs, locks persistence.
*   **Backend Service (app):** Runs Apache/PHP-FPM internally on port 80, mapped to host ports (5501 for Dev, 5502 for Demo).
*   **Frontend Service (nginx):** Serves static files from `public/` and proxies API requests to the backend. Mapped to host ports (6501 for Dev, 6502 for Demo).
*   **Trade Server Integration:** The bot fetches external market data and potentially executes trades via a Trade Server API:
    *   Development Bot connects to: `http://164.68.117.90:18080`
    *   Demo Bot connects to: `http://195.7.7.93:18080`

### How It All Ties Together

1.  **Initialization:** `rebuild-all.sh` orchestrates Docker Compose to build/start containers for Dev and Demo. Backend containers load initial bot configurations from `config/bots_config.json`.
2.  **Operation:** The core bot logic (`src/core/TradingBot.php`), possibly using an event loop (`react/event-loop`), runs continuously, fetching market data, managing its orders according to its configuration, and interacting with the Trade Server API.
3.  **API Interaction:** External requests (e.g., from the Frontend UI or other tools) hit `api/api.php`. Nginx proxies these requests to the Apache/PHP backend. The API script processes requests, interacts with the running bot instances or configuration, and returns responses.
4.  **Frontend:** Nginx serves the static frontend application (HTML/CSS/JS from `public/`). The frontend application makes calls to the backend API (`/api/*`) to fetch data or trigger actions. Swagger UI is served via the backend URL.
5.  **Monitoring:** Logs are written to the `data/logs/` directory. CLI tools (`OrderBookConsoleTool.*`) can be used for real-time order book monitoring.

### Summary

The Trading Bot project features a containerized, modular architecture using PHP/Apache for the backend/API and Nginx for the frontend. Docker and Docker Compose ensure consistent environments (Development and Demo) and simplify deployment. Configuration is managed via JSON and PHP files, while Swagger provides API documentation. Shell scripts automate common tasks. The system interacts with an external Trade Server API for market data and order execution, aiming to maintain a populated order book based on configured parameters. 